/*
        Leeds University Rocketry Organisation - LURA
  Author Name:
  Created on:
  Description: Driver file for the GNSS module MAX-M10S-00B
  (https://www.mouser.co.uk/ProductDetail/u-blox/MAX-M10S-00B?qs=A6eO%252BMLsxmT0PfQYPb7LLQ%3D%3D)
*/

// https://content.u-blox.com/sites/default/files/u-blox-M10-SPG-5.10_InterfaceDescription_UBX-21035062.pdf

#include "MAXM10S_driver.h"

#include <fcntl.h>
#include <stdarg.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <string.h>
#include <time.h> 

#include "lib/log.h"
#include "HAL/mcu.h"

MAX10M10S_data latest_data; 

MAX10M10S_data *MAXM10S_get_latest_data() {
  return &latest_data;
}

uint8_t MAXM10S_init(USART_TypeDef *uart) {
  // char* command = "<UBX(CFG-MSG, msgClass=NAV, msgID=NAV-STATUS, rateDDC=0, rateUART1=1, rateUART2=0, rateUSB=0, rateSPI=0, reserved=0)>";
  uint8_t command[] = {0x0A, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x21, 0x30, 0x10, 0x27, 0x24, 0x38};

  uart_write_buf(uart, command, sizeof(command));
  return 0;
}

uint8_t MAXM10S_preset_tracker(USART_TypeDef *uart) {
  // List of UBX commands to send
  const uint8_t cmds[][20] = {
    {0xB5,0x62,0x06,0x8A,0x09,0x00,0x00,0x01,0x00,0x00,0x20,0x00,0x31,0x10,0x00,0xFB,0x84},
    {0xB5,0x62,0x06,0x8A,0x09,0x00,0x00,0x02,0x00,0x00,0x20,0x00,0x31,0x10,0x00,0xFC,0x8C},
    {0xB5,0x62,0x06,0x8A,0x09,0x00,0x00,0x01,0x00,0x00,0x21,0x00,0x11,0x20,0x03,0xEF,0x4C},
    {0xB5,0x62,0x06,0x8A,0x09,0x00,0x00,0x02,0x00,0x00,0x21,0x00,0x11,0x20,0x03,0xF0,0x54},
    {0xB5,0x62,0x06,0x8A,0x09,0x00,0x00,0x01,0x00,0x00,0x05,0x00,0x22,0x20,0x00,0xE1,0xF0},
    {0xB5,0x62,0x06,0x8A,0x09,0x00,0x00,0x02,0x00,0x00,0x05,0x00,0x22,0x20,0x00,0xE2,0xF8},
    {0xB5,0x62,0x06,0x8A,0x0A,0x00,0x00,0x01,0x00,0x00,0xB3,0x00,0x11,0x30,0x1E,0x00,0xAD,0x19},
    {0xB5,0x62,0x06,0x8A,0x0A,0x00,0x00,0x02,0x00,0x00,0xB3,0x00,0x11,0x30,0x1E,0x00,0xAE,0x22},
    {0xB5,0x62,0x06,0x8A,0x09,0x00,0x00,0x01,0x00,0x00,0x07,0x00,0x91,0x20,0x01,0x53,0x48},
    {0xB5,0x62,0x06,0x8A,0x09,0x00,0x00,0x02,0x00,0x00,0x07,0x00,0x91,0x20,0x01,0x54,0x50},
    {0xB5,0x62,0x06,0x8A,0x09,0x00,0x00,0x01,0x00,0x00,0x16,0x00,0x91,0x20,0x01,0x62,0x93},
    {0xB5,0x62,0x06,0x8A,0x09,0x00,0x00,0x02,0x00,0x00,0x16,0x00,0x91,0x20,0x01,0x63,0x9B},
    {0xB5,0x62,0x06,0x8A,0x09,0x00,0x00,0x01,0x00,0x00,0x1B,0x00,0x91,0x20,0x01,0x67,0xAC},
    {0xB5,0x62,0x06,0x8A,0x09,0x00,0x00,0x02,0x00,0x00,0x1B,0x00,0x91,0x20,0x01,0x68,0xB4},
    {0xB5,0x62,0x06,0x8A,0x0C,0x00,0x00,0x01,0x00,0x00,0x02,0x00,0xD0,0x40,0x1E,0x00,0x00,0x00,0xCD,0xD1},
    {0xB5,0x62,0x06,0x8A,0x0C,0x00,0x00,0x02,0x00,0x00,0x02,0x00,0xD0,0x40,0x1E,0x00,0x00,0x00,0xCE,0xDC},
    {0xB5,0x62,0x06,0x8A,0x09,0x00,0x00,0x01,0x00,0x00,0x01,0x00,0xD0,0x20,0x02,0x8D,0xE8},
    {0xB5,0x62,0x06,0x8A,0x09,0x00,0x00,0x02,0x00,0x00,0x01,0x00,0xD0,0x20,0x02,0x8E,0xF0}
  };
  const size_t cmd_lens[] = {
    17,17,17,17,17,17,18,18,17,17,17,17,17,17,20,20,17,17
  };
  for (size_t i = 0; i < sizeof(cmds)/sizeof(cmds[0]); ++i) {
    uart_write_buf(uart, cmds[i], cmd_lens[i]);
    delay_ms(100);
  }
  return 0;  // Return success
}

// uint8_t MAXM10S_G2(USART_TypeDef *uart) {
//   const uint8_t cmds[][17] = {
//     {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xAC, 0x00, 0x91, 0x20, 0x01, 0xF8, 0x81},
//     {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xAD, 0x00, 0x91, 0x20, 0x01, 0xF9, 0x86},
//     {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xC0, 0x00, 0x91, 0x20, 0x00, 0x0B, 0xE4},
//     {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xC1, 0x00, 0x91, 0x20, 0x00, 0x0C, 0xE9},
//     {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xCA, 0x00, 0x91, 0x20, 0x00, 0x15, 0x16},
//     {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xCB, 0x00, 0x91, 0x20, 0x00, 0x16, 0x1B},
//     {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xB1, 0x00, 0x91, 0x20, 0x00, 0xFC, 0x99},
//     {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xB2, 0x00, 0x91, 0x20, 0x00, 0xFD, 0x9E},
//     {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xBB, 0x00, 0x91, 0x20, 0x00, 0x06, 0xCB},
//     {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xBC, 0x00, 0x91, 0x20, 0x00, 0x07, 0xD0},
//     {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xC5, 0x00, 0x91, 0x20, 0x00, 0x10, 0xFD},
//     {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xC6, 0x00, 0x91, 0x20, 0x00, 0x11, 0x02},
//     {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x8C, 0x02, 0x91, 0x20, 0x00, 0xD9, 0xE8},
//     {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x8D, 0x02, 0x91, 0x20, 0x00, 0xDA, 0xED},
//     {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x91, 0x04, 0x91, 0x20, 0x00, 0xE0, 0x09},
//     {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x92, 0x04, 0x91, 0x20, 0x00, 0xE1, 0x0E},
//     {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x07, 0x00, 0x91, 0x20, 0x00, 0x52, 0x47},
//     {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x08, 0x00, 0x91, 0x20, 0x00, 0x53, 0x4C},
//     {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x8D, 0x02, 0x91, 0x20, 0x00, 0xDA, 0xED}
//   };
//   for (size_t i = 0; i < sizeof(cmds)/sizeof(cmds[0]); ++i) {
//     uart_write_buf(uart, cmds[i], sizeof(cmds[i]));
//     delay_ms(100);
//   }
//   return 0;
// }

uint8_t MAXM10S_G2(USART_TypeDef *uart) {
  const uint8_t cmds[][17] = {
    {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xAC, 0x00, 0x91, 0x20, 0x00, 0xF7, 0x80},
    {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xAD, 0x00, 0x91, 0x20, 0x00, 0xF8, 0x85},
    {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xC0, 0x00, 0x91, 0x20, 0x00, 0x0B, 0xE4},
    {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xC1, 0x00, 0x91, 0x20, 0x00, 0x0C, 0xE9},
    {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xCA, 0x00, 0x91, 0x20, 0x00, 0x15, 0x16},
    {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xCB, 0x00, 0x91, 0x20, 0x00, 0x16, 0x1B},
    {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xB1, 0x00, 0x91, 0x20, 0x00, 0xFC, 0x99},
    {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xB2, 0x00, 0x91, 0x20, 0x00, 0xFD, 0x9E},
    {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xBB, 0x00, 0x91, 0x20, 0x00, 0x06, 0xCB},
    {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xBC, 0x00, 0x91, 0x20, 0x00, 0x07, 0xD0},
    {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xC5, 0x00, 0x91, 0x20, 0x00, 0x10, 0xFD},
    {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xC6, 0x00, 0x91, 0x20, 0x00, 0x11, 0x02},
    {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x8C, 0x02, 0x91, 0x20, 0x01, 0xDA, 0xE9},
    {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x8D, 0x02, 0x91, 0x20, 0x01, 0xDB, 0xEE},
    {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x91, 0x04, 0x91, 0x20, 0x01, 0xE1, 0x0A},
    {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x92, 0x04, 0x91, 0x20, 0x01, 0xE2, 0x0F},
    {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x07, 0x00, 0x91, 0x20, 0x01, 0x53, 0x48},
    {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x08, 0x00, 0x91, 0x20, 0x01, 0x54, 0x4D}
  };
  for (size_t i = 0; i < sizeof(cmds)/sizeof(cmds[0]); ++i) {
    uart_write_buf(uart, cmds[i], sizeof(cmds[i]));
    delay_ms(100);
  }
  return 0;
}

uint8_t PARSE_NAV_PVT(uint8_t *buf, MAX10M10S_data *data) {
  char header[3];
  header[0] = buf[0];
  header[1] = buf[1];
  header[2] = '\0';

  char class[1];
  class[0] = buf[2];

  char ID[1];
  ID[0] = buf[3];

  // Interpret length as integer (little-endian)
  uint16_t length = buf[4] | (buf[5] << 8);

  // Use a static buffer for payload, assuming NAV-PVT payload is max 92 bytes (see u-blox spec)
  if (length > 92) {
    loge("Payload length too large: %u\n", length);
    return 1;
  }
  uint8_t payload[92];
  memcpy(payload, &buf[6], length);

  // logi("Header: %s, Class: %s, ID: %s, Length: %d\n", header, class, ID, length);

  uint32_t iTOW = payload[0] | (payload[1] << 8) | (payload[2] << 16) | (payload[3] << 24);
  uint16_t year = payload[4] | (payload[5] << 8);
  uint8_t month = payload[6];
  uint8_t day = payload[7];
  uint8_t hour = payload[8];
  uint8_t min = payload[9];
  uint8_t sec = payload[10];

  uint8_t valid = payload[11];
  uint32_t tAcc = payload[12] | (payload[13] << 8) | (payload[14] << 16) | (payload[15] << 24);
  int32_t nano = payload[16] | (payload[17] << 8) | (payload[18] << 16) | (payload[19] <<24);
  uint8_t fixType = payload[20];
  uint8_t flags = payload[21];
  uint8_t flags2 = payload[22];
  uint8_t numSV = payload[23];
  int32_t lon = payload[24] | (payload[25] << 8) | (payload[26] << 16) | (payload[27] << 24);
  int32_t lat = payload[28] | (payload[29] << 8) | (payload[30] << 16) | (payload[31] << 24);
  int32_t height = payload[32] | (payload[33] << 8) | (payload[34] << 16) | (payload[35] << 24);
  int32_t hMSL = payload[36] | (payload[37] << 8) | (payload[38] << 16) | (payload[39] << 24);
  uint32_t hAcc = payload[40] | (payload[41] << 8) | (payload[42] << 16) | (payload[43] << 24);
  uint32_t vAcc = payload[44] | (payload[45] << 8) | (payload[46] << 16) | (payload[47] << 24);
  int32_t velN = payload[48] | (payload[49] << 8) | (payload[50] << 16) | (payload[51] << 24);
  int32_t velE = payload[52] | (payload[53] << 8) | (payload[54] << 16) | (payload[55] << 24);
  int32_t velD = payload[56] | (payload[57] << 8) | (payload[58] << 16) | (payload[59] << 24);
  uint32_t gSpeed = payload[60] | (payload[61] << 8) | (payload[62] << 16) | (payload[63] << 24);
  int32_t headMot = payload[64] | (payload[65] << 8) | (payload[66] << 16) | (payload[67] << 24);
  uint32_t sAcc = payload[68] | (payload[69] << 8) | (payload[70] << 16) | (payload[71] << 24);
  uint32_t headAcc = payload[72] | (payload[73] << 8) | (payload[74] << 16) | (payload[75] << 24);
  
  // log timestamp
  // logi("Timestamp: %04d-%02d-%02d %02d:%02d:%02d.%09d\r\n", year, month, day, hour, min, sec, nano);
  // logi("Fix: %d\r\n", fixType);
  // logi("Position: lat=%d, lon=%d, height=%d, hMSL=%d\r\n", lat, lon, height, hMSL);

  struct tm timeinfo;
  timeinfo.tm_year = year - 1900; // tm_year is years since 1900
  timeinfo.tm_mon = month - 1; // tm_mon is 0-11
  timeinfo.tm_mday = day;
  timeinfo.tm_hour = hour;
  timeinfo.tm_min = min;
  timeinfo.tm_sec = sec;
  time_t timestamp = mktime(&timeinfo);

  data->lat = lat;
  data->lon = lon;
  data->height_MSL = hMSL;
  data->fixType = fixType;
  data->numSV = numSV;
  data->nanoseconds = nano;
  latest_data = *data;
  return 0;
}

