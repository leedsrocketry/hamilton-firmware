#ifndef MAXM10S_DRIVER_H
#define MAXM10S_DRIVER_H

#include <stdint.h>

union u_Short
{
	uint8_t bytes[2];
	unsigned short uShort;
};

union i_Short
{
	uint8_t bytes[2];
	signed short iShort;
};

union u_Long
{
	uint8_t bytes[4];
	unsigned long uLong;
};

union i_Long
{
	uint8_t bytes[4];
	signed long iLong;
};


/**
 * @brief GNSS MAX driver buffer size.
 * @details Specified size of driver ring buffer.
 */
#define DRV_BUFFER_SIZE_TX      100
#define DRV_BUFFER_SIZE_RX      700



/**
 * @brief GNSS MAX10S stats object.
 * @details Statistics object definition of GNSS MAX10S driver.
 */
typedef struct
{
	UART_HandleTypeDef *huart;

	uint8_t uniqueID[4];
	uint8_t uartWorkingBuffer[101];

	unsigned short year;
	uint8_t yearBytes[2];
	uint8_t month;
	uint8_t day;
	uint8_t hour;
	uint8_t min;
	uint8_t sec;
	uint8_t fixType;

	signed long lon;
	uint8_t lonBytes[4];
	signed long lat;
	uint8_t latBytes[4];
	float fLon;
	float fLat;

	signed long height;
	signed long hMSL;
	uint8_t hMSLBytes[4];
	unsigned long hAcc;
	unsigned long vAcc;

	signed long gSpeed;
	uint8_t gSpeedBytes[4];
	signed long headMot;

}GNSS_StateHandle;
GNSS_StateHandle GNSS_Handle;



/**
 * @brief GNSS MAX context object.
 * @details Context object definition of GNSS MAX driver.
 */
typedef struct
{
    // Output pins
    digital_out_t rst;                          /**< Reset. */
    digital_out_t ext;                          /**< External interrupt. */

    // Input pins
    digital_in_t pps;                           /**< Timestamp. */

    // Modules
    uart_t uart;                                /**< UART driver object. */

    // Buffers
    char uart_rx_buffer[ DRV_BUFFER_SIZE_RX ];  /**< Buffer size. */
    char uart_tx_buffer[ DRV_BUFFER_SIZE_TX ];  /**< Buffer size. */

} GNSS_Context;



/**
 * @brief GNSS MAX10S configuration object.
 * @details Configuration object definition of GNSS MAX10S driver.
 */
typedef struct
{
    // Communication gpio pins
    pin_name_t rx_pin;                  /**< RX pin. */
    pin_name_t tx_pin;                  /**< TX pin. */

    // Additional gpio pins
    pin_name_t rst;                     /**< Reset pin. */
    pin_name_t ext;                     /**< External interrupt. */
    pin_name_t pps;                     /**< Timestamp. */

    // Static variable
    uint32_t          baud_rate;        /**< Clock speed. */
    bool              uart_blocking;    /**< Wait for interrupt or not. */
    uart_data_bits_t  data_bit;         /**< Data bits. */
    uart_parity_t     parity_bit;       /**< Parity bit. */
    uart_stop_bits_t  stop_bit;         /**< Stop bits. */

} GNSS_Config;



/**
 * @brief GNSS MAX10S return value data.
 * @details Predefined enum values for driver return values.
 */
typedef enum
{
   GNSSMAX_OK = 0,
   GNSSMAX_ERROR = -1,
   GNSSMAX_ERROR_NO_DATA = -2,
   GNSSMAX_ERROR_OVERFLOW = -3

} GNSS_ReturnValue;



/**
 * @brief GNSS MAX10S Class.
 * @details Class that holds all of the interaction points with the GNSS Driver.
 */
class MAXM10S_driver 
{
	public:
		/**
		 * @brief GNSS MAX configuration object setup function.
		 * @details This function initializes GNSS to initial values.
		 * @param[out] config : Configuration structure.
		 * @return Nothing.
		 */
		void config_setup(GNSS_Config *config);


		/**
		 * @brief GNSS MAX initialization function.
		 * @details This function initializes all necessary pins and peripherals.
		 * @param[out] ctx : Context object.
		 * @param[in] config : Configuration structure.
		 * @return @li @c  0 - Success,
		 *         @li @c -1 - Error.
		 */
		void init(GNSS_Context *ctx, GNSS_Config *config);

		
		/**
		 * @brief GNSS MAX reset function.
		 * @details This function toggles reset pin to reset module.
		 * @param[in] ctx : Context object.
		 */
		void reset(GNSS_Context *ctx);


		/**
		 * @brief GNSS MAX sets state of external interrupt.
		 * @details This function sets logic state of @b ext_int pin.
		 * @param[in] ctx : Context object.
		 * @param[in] state : State of pin to set.
		 */
		void set_external_interrupt(GNSS_Context *ctx, uint8_t state);
			

		/**
		 * @brief GNSS MAX data writing function.
		 * @details This function writes a desired number of data bytes by using UART serial interface.
		 * @param[in] ctx : Context object.
		 * @param[in] data_buf : Data buffer for sending.
		 * @param[in] len : Number of bytes for sending.
		 * @return @li @c  >=0 - Success,
		 *         @li @c   <0 - Error.
		 */
		void write(GNSS_Context *ctx, char *data_buf, uint16_t len);

		/**
		 * @brief GNSS MAX data reading function.
		 * @details This function reads a desired number of data bytes by using UART serial interface.
		 * @param[in] ctx : Context object.
		 * @param[out] data_buf : Output read data.
		 * @param[in] max_len : Number of bytes to be read.
		 * @return @li @c  >0 - Number of data bytes read,
		 *         @li @c <=0 - Error/Empty Ring buffer.
		 */
		void read(GNSS_Context *ctx, char *data_buf, uint16_t max_len);
};

#endif /* MAXM10S_DRIVER_H */



/*
enum GNSSMode{Portable=0, Stationary=1, Pedestrian=2, Automotiv=3, Sea=4, Airbone1G=5, Airbone2G=6, Airbone4G=7, Wirst=8};

static const uint8_t configUBX[]={0xB5,0x62,0x06,0x00,0x14,0x00,0x01,0x00,0x00,0x00,0xD0,0x08,0x00,0x00,0x80,0x25,0x00,0x00,0x01,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x9A,0x79};

static const uint8_t setNMEA410[]={0xB5,0x62,0x06,0x17,0x14,0x00,0x00,0x41,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x75,0x57};

// Activation of navigation system: Galileo, Glonass, GPS, SBAS, IMES
static const uint8_t setGNSS[]={0xB5,0x62,0x06,0x3E,0x24,0x00,0x00,0x00,0x20,0x04,0x00,0x08,0x10,0x00,0x01,0x00,0x01,0x01,0x01,0x01,0x03,0x00,0x01,0x00,0x01,0x01,0x02,0x04,0x08,0x00,0x01,0x00,0x01,0x01,0x06,0x08,0x0E,0x00,0x01,0x00,0x01,0x01,0xDF,0xFB};

static const uint8_t getDeviceID[]={0xB5,0x62,0x27,0x03,0x00,0x00,0x2A,0xA5};

static const uint8_t getNavigatorData[]={0xB5,0x62,0x01,0x21,0x00,0x00,0x22,0x67};

static const uint8_t getPOSLLHData[]={0xB5,0x62,0x01,0x02,0x00,0x00,0x03,0x0A};

static const uint8_t getPVTData[]={0xB5,0x62,0x01,0x07,0x00,0x00,0x08,0x19};

//  Navigation configuration
static const uint8_t setPortableMode[]={0xB5,0x62,0x06,0x24,0x24,0x00,0xFF,0xFF,0x00,0x03,0x00,0x00,0x00,0x00,0x10,0x27,0x00,0x00,0x05,0x00,0xFA,0x00,0xFA,0x00,0x64,0x00,0x5E,0x01,0x00,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x3C};

static const uint8_t setStationaryMode[]={0xB5,0x62,0x06,0x24,0x24,0x00,0xFF,0xFF,0x02,0x03,0x00,0x00,0x00,0x00,0x10,0x27,0x00,0x00,0x05,0x00,0xFA,0x00,0xFA,0x00,0x64,0x00,0x5E,0x01,0x00,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80};

static const uint8_t setPedestrianMode[]={0xB5,0x62,0x06,0x24,0x24,0x00,0xFF,0xFF,0x03,0x03,0x00,0x00,0x00,0x00,0x10,0x27,0x00,0x00,0x05,0x00,0xFA,0x00,0xFA,0x00,0x64,0x00,0x5E,0x01,0x00,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x81,0xA2};

static const uint8_t setAutomotiveMode[]={0xB5,0x62,0x06,0x24,0x24,0x00,0xFF,0xFF,0x04,0x03,0x00,0x00,0x00,0x00,0x10,0x27,0x00,0x00,0x05,0x00,0xFA,0x00,0xFA,0x00,0x64,0x00,0x5E,0x01,0x00,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x82,0xC4};

static const uint8_t setSeaMode[]={0xB5,0x62,0x06,0x24,0x24,0x00,0xFF,0xFF,0x05,0x03,0x00,0x00,0x00,0x00,0x10,0x27,0x00,0x00,0x05,0x00,0xFA,0x00,0xFA,0x00,0x64,0x00,0x5E,0x01,0x00,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x83,0xE6};

static const uint8_t setAirbone1GMode[]={0xB5,0x62,0x06,0x24,0x24,0x00,0xFF,0xFF,0x06,0x03,0x00,0x00,0x00,0x00,0x10,0x27,0x00,0x00,0x05,0x00,0xFA,0x00,0xFA,0x00,0x64,0x00,0x5E,0x01,0x00,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x84,0x08};

static const uint8_t setAirbone2GMode[]={0xB5,0x62,0x06,0x24,0x24,0x00,0xFF,0xFF,0x07,0x03,0x00,0x00,0x00,0x00,0x10,0x27,0x00,0x00,0x05,0x00,0xFA,0x00,0xFA,0x00,0x64,0x00,0x5E,0x01,0x00,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x85,0x2A};

static const uint8_t setAirbone4GMode[]={0xB5,0x62,0x06,0x24,0x24,0x00,0xFF,0xFF,0x08,0x03,0x00,0x00,0x00,0x00,0x10,0x27,0x00,0x00,0x05,0x00,0xFA,0x00,0xFA,0x00,0x64,0x00,0x5E,0x01,0x00,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x86,0x4C};

static const uint8_t setWirstMode[]={0xB5,0x62,0x06,0x24,0x24,0x00,0xFF,0xFF,0x09,0x03,0x00,0x00,0x00,0x00,0x10,0x27,0x00,0x00,0x05,0x00,0xFA,0x00,0xFA,0x00,0x64,0x00,0x5E,0x01,0x00,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x87,0x6E};


static const uint8_t setPortableType[]={};
void GNSS_Init(GNSS_StateHandle *GNSS, UART_HandleTypeDef *huart);
void GNSS_LoadConfig(GNSS_StateHandle *GNSS);
void GNSS_ParseBuffer(GNSS_StateHandle *GNSS);

void GNSS_GetUniqID(GNSS_StateHandle *GNSS);
void GNSS_ParseUniqID(GNSS_StateHandle *GNSS);

void GNSS_GetNavigatorData(GNSS_StateHandle *GNSS);
void GNSS_ParseNavigatorData(GNSS_StateHandle *GNSS);

void GNSS_GetPOSLLHData(GNSS_StateHandle *GNSS);
void GNSS_ParsePOSLLHData(GNSS_StateHandle *GNSS);

void GNSS_GetPVTData(GNSS_StateHandle *GNSS);
void GNSS_ParsePVTData(GNSS_StateHandle *GNSS);

void GNSS_SetMode(GNSS_StateHandle *GNSS, short gnssMode); */